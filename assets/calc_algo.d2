
cTrnDao: CalcTrnDao {
    q: Query {
        ByTime
        ByCategory
        ByAccount
        ByPurpose
    }
    sql: "SQL: O(trns.count) time | O(trns.notDel.count) space" {
        "SELECT amount, currency, type FROM transactions WHERE ..."
    }
    trns: "List<CalcTrn>" {
        amount
        currency
        type
    }

    q -> sql -> trns
}

rawStatsFlow: RawStatsFlow {
    in: Input {
        trns: "trns: List<CalcTrn>"
    }

    p: "Process: O(trns.count) time | O(currs.unique.count) space" {
        "trns.forEach { aggregate incomes, expense by currencies + count them }"
    } 

    out: RawStats {
        "incomes: Map<CurrencyCode, Double>"
        "expenses: Map<CurrencyCode, Double>"
        "incomesCount: Int"
        "expensesCount: Int"
    }

    in -> p -> out
}

cTrndao.trns -> rawStatsFlow.in.trns

# RatesFlow
ratesDao: RatesDao {
    sql: "SQL: O(rates.count) time | O(rates.baseCurr.count) space" {
        "SELECT rate, currency FROM exchange_rates WHERE baseCurrency = ?"
    }
    out: "List<Rate>" {
        rate
        currency
    } 
    sql -> out
}

ratesOverrideDao: RateOverrideDao {
    sql: "SQL: O(rates.override.count) time | O(rates.override.baseCurr.count) space" {
        "SELECT rate, currency FROM exchange_rates_override WHERE baseCurrency = ? AND sync != $DELETING"
    }
    out: "List<Rate>" {
        rate
        currency
    } 
    sql -> out
}

ratesFlow: RatesFlow {
    deps: Dependencies {
        ratesDao
        ratesOverrideDao
        baseCurrencyFlow
    }
    p: "Process: O(rates.override.count) time | O(1) space" {
        1: "baseCurrency.flatMapLatest {}"
        2: "combine(rateDao.findByBaseCurr(), ratesOverridedao.findByBaseCurr())"
        3: "Override rate with the manual set ones"

        1 -> 2 -> 3
        
    }
    out: "RatesData" {
        baseCurrency
        "rates: Map<CurrencyCode, Double>"
    }

    deps.ratesDao -> p: Reacts
    deps.ratesOverrideDao -> p: Reacts
    deps.baseCurrencyFlow -> p: Reacts
    p -> out
}

ratesDao -> ratesFlow.deps
ratesOverrideDao -> ratesFlow.deps


# ExchangeStatsFlow
exFlow: ExchangeStatsFlow {
    deps: Dependencies {
        ratesFlow: "rates: RatesFlow"
    }

    in: Input {
        rawStats: "rawStats: RawStats"
    }

    p: "Process: O(curr.unique.count) time | O(1) space" {
        "Exchange & aggregate each unique currency in the RawStats"
    }

    out: Stats {
        "income: Value"
        "expense: Value"
        "incomesCount: Int"
        "expensesCount: Int"
    }

    deps.rates -> p: Reacts to rates changes
    in.rawStats -> p
    p -> out
}

ratesFlow.out -> exFlow.deps.ratesFlow: Reacts
rawStatsFlow.out -> exFlow.in.rawStats


